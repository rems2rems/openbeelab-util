// Generated by CoffeeScript 1.10.0
(function() {
  var method, methodName, ref, utils,
    hasProp = {}.hasOwnProperty;

  utils = {
    sum: function() {
      return this.reduce((function(memo, n) {
        return n + memo;
      }), 0);
    },
    reject: function(cond) {
      var elem;
      return (function() {
        var l, len, results;
        results = [];
        for (l = 0, len = this.length; l < len; l++) {
          elem = this[l];
          if (!cond(elem)) {
            results.push(elem);
          }
        }
        return results;
      }).call(this);
    },
    detect: function(cond) {
      var elem, elems;
      elems = (function() {
        var l, len, results;
        results = [];
        for (l = 0, len = this.length; l < len; l++) {
          elem = this[l];
          if (cond(elem)) {
            results.push(elem);
          }
        }
        return results;
      }).call(this);
      if (elems.length === 1) {
        return elems[0];
      } else {
        return null;
      }
    },
    sortComparables: function() {
      if (this.length < 2) {
        return this;
      }
      return this.sort(function(a, b) {
        return a.compareTo(b);
      });
    },
    pluck: function(prop) {
      return this.map(function(e) {
        return e[prop];
      });
    },
    dup: function() {
      return this.slice();
    },
    remove: function(e) {
      var res;
      res = this.dup();
      res.splice(this.indexOf(e), 1);
      return res;
    },
    removeAll: function(other) {
      return this.filter(function(e) {
        return other.indexOf(e) < 0;
      });
    },
    unique: function() {
      return this.filter(function(e, index, array) {
        return array.indexOf(e) === index;
      });
    },
    max: function() {
      var max;
      if (this.length === 0) {
        return null;
      }
      max = this[0];
      this.forEach(function(e) {
        if (e != null ? e.isGreaterThan(max) : void 0) {
          return max = e;
        }
      });
      return max;
    },
    min: function() {
      var min;
      if (this.length === 0) {
        return null;
      }
      min = this[0];
      this.forEach(function(e) {
        if (e != null ? e.isLesserThan(min) : void 0) {
          return min = e;
        }
      });
      return min;
    },
    contains: function(e) {
      return this.indexOf(e) >= 0;
    },
    shuffle: function() {
      var i, j, l, ref, ref1, results;
      results = [];
      for (i = l = ref = this.length - 1; ref <= 1 ? l <= 1 : l >= 1; i = ref <= 1 ? ++l : --l) {
        j = Math.floor(Math.random() * (i + 1));
        results.push((ref1 = [this[j], this[i]], this[i] = ref1[0], this[j] = ref1[1], ref1));
      }
      return results;
    },
    pickRandom: function() {
      var i;
      if (this.length === 0) {
        return null;
      }
      i = Math.floor(Math.random() * this.length);
      return this[i];
    },
    isEmpty: function() {
      return this.length === 0;
    },
    cycle: function(nb, cb) {
      if ((nb != null) && (cb != null)) {
        nb.times((function(_this) {
          return function() {
            var elem, l, len, results;
            results = [];
            for (l = 0, len = _this.length; l < len; l++) {
              elem = _this[l];
              results.push(cb(elem));
            }
            return results;
          };
        })(this));
        return;
      }
      if ((nb != null) && (cb == null)) {
        cb = nb;
        return nb = "infinity!";
      }
    },
    head: function() {
      return this[0];
    },
    tail: function() {
      return this.slice(1, +(this.length - 1) + 1 || 9e9);
    },
    init: function() {
      return this.slice(0, +(this.length - 2) + 1 || 9e9);
    },
    last: function() {
      return this[this.length - 1];
    },
    combinations: function(k) {
      var combs, elem, head, i, l, len, m, ref, tailcomb, tailcombs;
      if (k > this.length || k <= 0) {
        return [];
      }
      if (k === this.length) {
        return [this];
      }
      if (k === 1) {
        return (function() {
          var l, len, results;
          results = [];
          for (l = 0, len = this.length; l < len; l++) {
            elem = this[l];
            results.push([elem]);
          }
          return results;
        }).call(this);
      }
      combs = [];
      for (i = l = 0, ref = this.length - k + 1; 0 <= ref ? l <= ref : l >= ref; i = 0 <= ref ? ++l : --l) {
        head = this.slice(i, i + 1);
        tailcombs = this.slice(i + 1).combinations(k - 1);
        for (m = 0, len = tailcombs.length; m < len; m++) {
          tailcomb = tailcombs[m];
          combs.push(head.concat(tailcomb));
        }
      }
      return combs;
    },
    compareTo: function(other) {
      return this.length - other.length;
    }
  };

  ref = require('./comparable');
  for (methodName in ref) {
    if (!hasProp.call(ref, methodName)) continue;
    method = ref[methodName];
    utils[methodName] = method;
  }

  utils.install = function() {
    for (methodName in utils) {
      method = utils[methodName];
      if ((Array.prototype[methodName] == null) && methodName !== "install") {
        Array.prototype[methodName] = method;
      }
    }
    return Object.prototype.isArray = function() {
      return Object.prototype.toString.call(this) === '[object Array]';
    };
  };

  module.exports = utils;

}).call(this);
